---
layout: post
title: "You may not need that code later"
description: ""
category: 
tags: []
---

Determining the best process for writing good software is answering the question:
> What can be done in the least amount of time to save the most amount of time?

It's an optimization problem and the time saved is value delivered.

As a developer, your input is a todo list and your output
is some code. As you take items off of your todo list, you'll be tempted to
engineer solutions to items further down in the list. Your mind may trail off
towards:

> I know I'll need to diplay this data I just fetched from an API on another
> screen later, so I'll just persist it now.

It may seem like common sense, but it's not. It's a shortcut and you shouldn't
take it. Your engineer brain just smuggled the woes of taking shitty shortcuts
behind the mask of clever forsight.

As a developer, you need to stop thinking:
> While I'm here, I'll write this code because I know I'll need it later

and start exclusively solving the problem in front of you.

Otherwise, you're creating potential cruft and adding unecessary complexity.
You're also ransoming the potential value of this story for a *peice* of the
potential value of another. Remember that value is time saved and we're
only talking about potential value. Nobody knows for sure yet if either stories
are going to save anybody any time until one of them gets out the door.

No matter how sure you are:

# You may not need that code later

Though it may seem counter-intuitive at first, this process obviously
results in software getting into the hands of users faster. And if you saved
them time, you delivered value to them. Otherwise, you know that much sooner
what isn't saving them time.

If you're ruthless about only solving the problem at hand, you'll be happier.
